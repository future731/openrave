[1mdiff --git a/include/openrave/collisionchecker.h b/include/openrave/collisionchecker.h[m
[1mindex e1bdbc5e6..3654284e6 100644[m
[1m--- a/include/openrave/collisionchecker.h[m
[1m+++ b/include/openrave/collisionchecker.h[m
[36m@@ -80,6 +80,7 @@[m [mpublic:[m
     virtual std::string __str__() const;[m
 [m
     KinBody::LinkConstPtr plink1, plink2; ///< the colliding links if a collision involves a bodies. Collisions do not always occur with 2 bodies like ray collisions, so these fields can be empty.[m
[32m+[m[32m    KinBody::GeometryInfoConstPtr pgeominfo1, pgeominfo2; ///< the specified geometries hit for the given links[m
 [m
     std::vector<std::pair<KinBody::LinkConstPtr, KinBody::LinkConstPtr> > vLinkColliding; ///< all link collision pairs. Set when CO_AllCollisions is enabled.[m
 [m
[36m@@ -92,7 +93,6 @@[m [mpublic:[m
 [m
     uint8_t nKeepPrevious; ///< if 1, will keep all previous data when resetting the collision checker. otherwise will reset[m
 [m
[31m-    //KinBody::Link::GeomConstPtr pgeom1, pgeom2; ///< the specified geometries hit for the given links[m
 };[m
 [m
 typedef CollisionReport COLLISIONREPORT RAVE_DEPRECATED;[m
[1mdiff --git a/plugins/fclrave/fclcollision.h b/plugins/fclrave/fclcollision.h[m
[1mindex 3e935eed4..cfa417475 100644[m
[1m--- a/plugins/fclrave/fclcollision.h[m
[1m+++ b/plugins/fclrave/fclcollision.h[m
[36m@@ -638,6 +638,8 @@[m [mpublic:[m
         FCLSpace::KinBodyInfo::LinkInfo objUserData;[m
 [m
         CollisionGeometryPtr ctrigeom = _fclspace->GetMeshFactory()(_fclPointsCache, _fclTrianglesCache);[m
[32m+[m[32m        // TODO Converting Trimesh into GeometryInfo is desired. be careful with the object lifespan[m
[32m+[m[32m        ctrigeom->setUserData(nullptr);[m
         fcl::CollisionObject ctriobj(ctrigeom);[m
         //ctriobj.computeAABB(); // necessary?[m
         ctriobj.setUserData(&objUserData);[m
[36m@@ -681,6 +683,8 @@[m [mpublic:[m
         FCLSpace::KinBodyInfo::LinkInfo objUserData;[m
 [m
         CollisionGeometryPtr ctrigeom = _fclspace->GetMeshFactory()(_fclPointsCache, _fclTrianglesCache);[m
[32m+[m[32m        // TODO Converting Trimesh into GeometryInfo is desired. be careful with the object lifespan[m
[32m+[m[32m        ctrigeom->setUserData(nullptr);[m
         fcl::CollisionObject ctriobj(ctrigeom);[m
         //ctriobj.computeAABB(); // necessary?[m
         ctriobj.setUserData(&objUserData);[m
[36m@@ -708,6 +712,8 @@[m [mpublic:[m
         FCLSpace::KinBodyInfo::LinkInfo objUserData;[m
 [m
         CollisionGeometryPtr cboxgeom = make_shared<fcl::Box>(ab.extents.x*2,ab.extents.y*2,ab.extents.z*2);[m
[32m+[m[32m        // TODO Converting Trimesh into GeometryInfo is desired. be careful with the object lifespan[m
[32m+[m[32m        cboxgeom->setUserData(nullptr);[m
         fcl::CollisionObject cboxobj(cboxgeom);[m
 [m
         fcl::Vec3f newPosition = ConvertVectorToFCL(aabbPose * ab.pos);[m
[36m@@ -749,6 +755,8 @@[m [mpublic:[m
 [m
         CollisionGeometryPtr cboxgeom = make_shared<fcl::Box>(ab.extents.x*2,ab.extents.y*2,ab.extents.z*2);[m
         fcl::CollisionObject cboxobj(cboxgeom);[m
[32m+[m[32m        // TODO Converting Trimesh into GeometryInfo is desired. be careful with the object lifespan[m
[32m+[m[32m        cboxgeom->setUserData(nullptr);[m
 [m
         fcl::Vec3f newPosition = ConvertVectorToFCL(aabbPose * ab.pos);[m
         fcl::Quaternion3f newOrientation = ConvertQuaternionToFCL(aabbPose.rot);[m
[36m@@ -1048,6 +1056,19 @@[m [mprivate:[m
                 _reportcache.plink1 = plink1;[m
                 _reportcache.plink2 = plink2;[m
 [m
[32m+[m[32m                KinBody::GeometryInfo* pgeominfo1 = static_cast<KinBody::GeometryInfo *>((*o1).collisionGeometry()->getUserData());[m
[32m+[m[32m                KinBody::GeometryInfo* pgeominfo2 = static_cast<KinBody::GeometryInfo *>((*o2).collisionGeometry()->getUserData());[m
[32m+[m[32m                if ( !!pgeominfo1 ) {[m
[32m+[m[32m                    _reportcache.pgeominfo1 = KinBody::GeometryInfoConstPtr(pgeominfo2);[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    RAVELOG_DEBUG_FORMAT("env=%s, fcl::CollisionObject o1 %x does not have GeometryInfo", GetEnv()->GetNameId()%o1);[m
[32m+[m[32m                }[m
[32m+[m[32m                if ( !!pgeominfo2 ) {[m
[32m+[m[32m                    _reportcache.pgeominfo2 = KinBody::GeometryInfoConstPtr(pgeominfo2);[m
[32m+[m[32m                } else {[m
[32m+[m[32m                    RAVELOG_DEBUG_FORMAT("env=%s, fcl::CollisionObject o2 %x does not have GeometryInfo", GetEnv()->GetNameId()%o2);[m
[32m+[m[32m                }[m
[32m+[m
                 // TODO : eliminate the contacts points (insertion sort (std::lower) + binary_search ?) duplicated[m
                 // How comes that there are duplicated contacts points ?[m
                 if( _options & (OpenRAVE::CO_Contacts | OpenRAVE::CO_AllGeometryContacts) ) {[m
[36m@@ -1072,6 +1093,8 @@[m [mprivate:[m
 [m
                 pcb->_report->plink1 = _reportcache.plink1;[m
                 pcb->_report->plink2 = _reportcache.plink2;[m
[32m+[m[32m                pcb->_report->pgeominfo1 = _reportcache.pgeominfo1;[m
[32m+[m[32m                pcb->_report->pgeominfo1 = _reportcache.pgeominfo2;[m
                 if( pcb->_report->contacts.size() == 0) {[m
                     pcb->_report->contacts.swap(_reportcache.contacts);[m
                 } else {[m
[36m@@ -1112,7 +1135,6 @@[m [mprivate:[m
 [m
     bool CheckNarrowPhaseDistance(fcl::CollisionObject *o1, fcl::CollisionObject *o2, CollisionCallbackData* pcb, fcl::FCL_REAL& dist) {[m
         std::pair<FCLSpace::KinBodyInfo::LinkInfo*, LinkConstPtr> o1info = GetCollisionLink(*o1), o2info = GetCollisionLink(*o2);[m
[31m-[m
         if( !o1info.second && !o1info.first ) {[m
             // o1 is standalone object[m
             if( _bParentlessCollisionObject && !!o2info.second ) {[m
[1mdiff --git a/plugins/fclrave/fclspace.h b/plugins/fclrave/fclspace.h[m
[1mindex 6bf0e972b..ad4a49231 100644[m
[1m--- a/plugins/fclrave/fclspace.h[m
[1m+++ b/plugins/fclrave/fclspace.h[m
[36m@@ -102,11 +102,14 @@[m [mpublic:[m
                     else {[m
                         RAVELOG_VERBOSE_FORMAT("resetting unknown link col=0x%x", (uint64_t)linkBV.second.get());[m
                     }[m
[32m+[m[32m                    // linkBV.second->collisionGeometry()->setUserData(nullptr); // since we don't need GeometryInfo in linkBV.second.collisionGeometry(), we don't have to erase it[m
                     linkBV.second->setUserData(nullptr); // reset the user data since someone can hold a ref to the collision object and continue using it[m
                 }[m
                 linkBV.second.reset();[m
 [m
                 FOREACH(itgeompair, vgeoms) {[m
[32m+[m[32m                    // unfortunately collisionGeometry() returns const reference, and getCollisionGeometry() is deprecated.[m
[32m+[m[32m                    // (*itgeompair).second->collisionGeometry()->setUserData(nullptr);[m
                     (*itgeompair).second->setUserData(nullptr);[m
                     (*itgeompair).second.reset();[m
                 }[m
[36m@@ -243,6 +246,7 @@[m [mpublic:[m
                         throw OpenRAVE::OpenRAVEException(str(boost::format("Failed to access geometry info %d for link %s:%s with geometrygroup %s")%igeominfo%plink->GetParent()->GetName()%plink->GetName()%pinfo->_geometrygroup), OpenRAVE::ORE_InvalidState);[m
                     }[m
                     const CollisionGeometryPtr pfclgeom = _CreateFCLGeomFromGeometryInfo(_meshFactory, *pgeominfo);[m
[32m+[m[32m                    pfclgeom->setUserData(pgeominfo.get());[m
 [m
                     if( !pfclgeom ) {[m
                         continue;[m
[36m@@ -267,6 +271,8 @@[m [mpublic:[m
                 FOREACH(itgeom, vgeometries) {[m
                     const KinBody::GeometryInfo& geominfo = (*itgeom)->GetInfo();[m
                     const CollisionGeometryPtr pfclgeom = _CreateFCLGeomFromGeometryInfo(_meshFactory, geominfo);[m
[32m+[m[32m                    pfclgeom->setUserData(&geominfo);[m
[32m+[m[32m                    pfclgeom->setUserData(nullptr);[m
 [m
                     if( !pfclgeom ) {[m
                         continue;[m
[1mdiff --git a/python/bindings/include/openravepy/openravepy_collisionreport.h b/python/bindings/include/openravepy/openravepy_collisionreport.h[m
[1mindex 1dfe246e7..1576a550d 100644[m
[1m--- a/python/bindings/include/openravepy/openravepy_collisionreport.h[m
[1m+++ b/python/bindings/include/openravepy/openravepy_collisionreport.h[m
[36m@@ -50,6 +50,8 @@[m [mpublic:[m
     int options;[m
     object plink1 = py::none_();[m
     object plink2 = py::none_();[m
[32m+[m[32m    object pgeominfo1 = py::none_();[m
[32m+[m[32m    object pgeominfo2 = py::none_();[m
     py::list vLinkColliding;[m
     dReal minDistance;[m
     int numWithinTol;[m
[1mdiff --git a/python/bindings/openravepy_collisionchecker.cpp b/python/bindings/openravepy_collisionchecker.cpp[m
[1mindex f6225888b..b34b790f5 100644[m
[1m--- a/python/bindings/openravepy_collisionchecker.cpp[m
[1m+++ b/python/bindings/openravepy_collisionchecker.cpp[m
[36m@@ -18,6 +18,7 @@[m
 #include <openravepy/openravepy_int.h>[m
 #include <openravepy/openravepy_kinbody.h>[m
 #include <openravepy/openravepy_environmentbase.h>[m
[32m+[m[32m#include <openravepy/openravepy_jointinfo.h>[m
 #include <openravepy/openravepy_collisionreport.h>[m
 #include <openravepy/openravepy_collisioncheckerbase.h>[m
 [m
[36m@@ -93,6 +94,17 @@[m [mvoid PyCollisionReport::init(PyEnvironmentBasePtr pyenv)[m
     else {[m
         plink2 = py::none_();[m
     }[m
[32m+[m
[32m+[m[32m    if( !!report->pgeominfo1 ) {[m
[32m+[m[32m        pgeominfo1 = py::to_object(PyGeometryInfoPtr(new PyGeometryInfo(*report->pgeominfo1)));[m
[32m+[m[32m    } else {[m
[32m+[m[32m        pgeominfo1 = py::none_();[m
[32m+[m[32m    }[m
[32m+[m[32m    if( !!report->pgeominfo2 ) {[m
[32m+[m[32m        pgeominfo2 = py::to_object(PyGeometryInfoPtr(new PyGeometryInfo(*report->pgeominfo2)));[m
[32m+[m[32m    } else {[m
[32m+[m[32m        pgeominfo2 = py::none_();[m
[32m+[m[32m    }[m
     py::list newcontacts;[m
     FOREACH(itc, report->contacts) {[m
         newcontacts.append(PYCONTACT(*itc));[m
[36m@@ -764,6 +776,8 @@[m [mvoid init_openravepy_collisionchecker()[m
     .def_readonly("options",&PyCollisionReport::options)[m
     .def_readonly("plink1",&PyCollisionReport::plink1)[m
     .def_readonly("plink2",&PyCollisionReport::plink2)[m
[32m+[m[32m    .def_readonly("pgeominfo1",&PyCollisionReport::pgeominfo1)[m
[32m+[m[32m    .def_readonly("pgeominfo2",&PyCollisionReport::pgeominfo2)[m
     .def_readonly("minDistance",&PyCollisionReport::minDistance)[m
     .def_readonly("numWithinTol",&PyCollisionReport::numWithinTol)[m
     .def_readonly("contacts",&PyCollisionReport::contacts)[m
